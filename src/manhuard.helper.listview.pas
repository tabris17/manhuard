unit Manhuard.Helper.ListView;

{$mode ObjFPC}{$H+}

interface

uses
  Classes, SysUtils, ComCtrls, Graphics, Generics.Collections, Manhuard.WorkPool;

const
  I_ICON_LOADER_FACTROY_GUID = '{08AD4BCD-12D4-4D8C-8E84-80CE88F3364E}';  // generated by IDE
  DEFAULT_CACHE_MAX_SIZE = 512;
  DEFAULT_CACHE_REGULAR_SIZE = 256;

type

  { TListViewIconManager }

  generic TListViewIconManager<TResolutionType> = class
  type
    { TResolution }

    TResolution = record
      Height: Integer;
      Width: Integer;
    end;
    TResolutions = array[TResolutionType] of TResolution;
    TIconTuple = array[TResolutionType] of TPicture;
    TIconCache = specialize TObjectDictionary<Integer, TIconTuple>;
    TIndexIconPair = specialize TPair<Integer, TIconTuple>;
    TIndexIconPairArray = array of TIndexIconPair;
    TLoadIconsWork = specialize TWork<TIndexIconPairArray>;
    THorizontalAlign = (haLeft, haCenter, haRight);
    TVerticalAlign = (vaTop, vaCenter, vaBottom);
    TPendingQueue = specialize TQueue<Integer>;
    TIndexArray = specialize TArray<Integer>;
    IIconLoaderFactroy = interface [I_ICON_LOADER_FACTROY_GUID]
      function BuildIconLoader(Indexes: TIndexArray): TLoadIconsWork;
    end;
  private
    FListView: TCustomListView;
    FResolutions: TResolutions;
    FDefaultIconTuple: TIconTuple;
    FIconCache: TIconCache;
    FPendingQueue: TPendingQueue;
    FIconLoaderFactroy: IIconLoaderFactroy;
  public
    constructor Create(ListView: TCustomListView; Resolutions: TResolutions; DefaultIconTuple: TIconTuple;
      IconLoaderFactroy: IIconLoaderFactroy);
    destructor Destroy; override;
    procedure DrawIcon(Item: TListItem; ResolutionType: TResolutionType;
      HAlign: THorizontalAlign = haLeft; VAlign: TVerticalAlign = vaTop);
    procedure Load(Data: PtrInt);
    procedure LoadSuccess(Sender: TLoadIconsWork; Return: TIndexIconPairArray);
  end;

implementation

uses Forms;

{ TListViewIconManager }

constructor TListViewIconManager.Create(ListView: TCustomListView; Resolutions: TResolutions; DefaultIconTuple: TIconTuple;
  IconLoaderFactroy: IIconLoaderFactroy);
begin
  FListView := ListView;
  FResolutions := Resolutions;
  FDefaultIconTuple := DefaultIconTuple;
  FIconLoaderFactroy := IconLoaderFactroy;
  FIconCache := TIconCache.Create;
  FPendingQueue := TPendingQueue.Create;
end;

destructor TListViewIconManager.Destroy;
var
  Icon: TPicture;
begin
  for Icon in FDefaultIconTuple do Icon.Free;
  FIconCache.Free;
  FPendingQueue.Free;
  inherited Destroy;
end;

procedure TListViewIconManager.DrawIcon(Item: TListItem; ResolutionType: TResolutionType;
  HAlign: THorizontalAlign; VAlign: TVerticalAlign);

  procedure HighlightFilter(Picture: TPicture);
  var
    PixelColor: TColor;
    X, Y: Integer;
  begin
    for X := 0 to Picture.Width - 1 do
    begin
      for Y := 0 to Picture.Height - 1 do
      begin
        PixelColor := Picture.Bitmap.Canvas.Pixels[X, Y];
        Picture.Bitmap.Canvas.Pixels[X, Y] := DecColor(PixelColor, $40);
      end;
    end;
  end;

  procedure LoseFocusFilter(Picture: TPicture);
  var
    PixelColor: TColor;
    X, Y: Integer;
  begin
    for X := 0 to Picture.Width - 1 do
    begin
      for Y := 0 to Picture.Height - 1 do
      begin
        PixelColor := Picture.Bitmap.Canvas.Pixels[X, Y];
        Picture.Bitmap.Canvas.Pixels[X, Y] := DecColor(PixelColor, $10);
      end;
    end;
  end;

var
  IconRect: TRect;
  Picture, FilteredPicture: TPicture;
  X, Y: Integer;
begin
  IconRect := Item.DisplayRect(drIcon);
  if FIconCache.ContainsKey(Item.Index) then
    Picture := FIconCache.Items[Item.Index][ResolutionType]
  else
  begin
    Picture := FDefaultIconTuple[ResolutionType];
    FPendingQueue.Enqueue(Item.Index);
    Application.QueueAsyncCall(@Load, 0);
  end;
  case HAlign of
    haLeft: X := IconRect.Left;
    haCenter: X := IconRect.Left + (IconRect.Width - Picture.Width) div 2;
    haRight:  X := IconRect.Left + IconRect.Width - Picture.Width;
  end;
  case VAlign of
    vaTop: Y := IconRect.Top;
    vaCenter: Y := IconRect.Top + (IconRect.Height - Picture.Height) div 2;
    vaBottom: Y := IconRect.Top + IconRect.Height - Picture.Height;
  end;

  if Item.Selected then
  begin
    FilteredPicture := TPicture.Create;
    try
      FilteredPicture.Assign(Picture); 
      if Item.Owner.Owner.Focused then HighlightFilter(FilteredPicture) else LoseFocusFilter(FilteredPicture);
      FListView.Canvas.Draw(X, Y, FilteredPicture.Graphic);
    finally
      FilteredPicture.Free;
    end;
  end
  else FListView.Canvas.Draw(X, Y, Picture.Graphic);
end;

procedure TListViewIconManager.Load(Data: PtrInt);
var
  Loader: TLoadIconsWork;
begin
  Application.RemoveAsyncCalls(Self);
  Loader := FIconLoaderFactroy.BuildIconLoader(FPendingQueue.ToArray);
  if Loader = nil then Exit;
  FPendingQueue.Clear;
  Loader.OnSuccess := @LoadSuccess;
  WorkPool.Exec(Loader);
end;

procedure TListViewIconManager.LoadSuccess(Sender: TLoadIconsWork; Return: TIndexIconPairArray);
var
  Item: TIndexIconPair;
begin
  for Item in Return do FIconCache.Add(Item);
  FListView.Repaint;
end;

end.

