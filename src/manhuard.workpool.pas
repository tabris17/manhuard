unit Manhuard.WorkPool;

{$mode ObjFPC}{$H+}

interface

uses
  Classes, SysUtils, Contnrs, Manhuard.Config, Windows;

const
  MAX_WORKPOOL_CAPACITY = 256;
  I_WORK_GUID = '{81297CBA-AAEF-4FD6-9F85-C70C5AC0CFFB}';  // generated by IDE

type
  EWork = class(Exception);
  EWorkCancel = class(EWork); // throw when State is wsCanceling
  EWorkResetWorker = class(EWork);
  EWorkBusyWorker = class(EWork);

  EWorkerPool = class(Exception);
  EInvalidCapacity = class(EWorkerPool);

  TWorkState = (wsPending = 0, wsRunning, wsSucceeded, wsFailed, wsCanceling, wsCancelled);
  TWorkPoolState = (wpsEmpty, wpsNotFull, wpsFull, wpsOverload);
  TWorker = class;
  TWorkPool = class;
  TWorkPoolCapacity = 1..MAX_WORKPOOL_CAPACITY;

  {$interfaces corba}

  { IWork }

  IWork = interface [I_WORK_GUID]
    procedure SetOwner(TheOwner: TWorker);
    procedure Run;
    procedure Cancel;
    procedure DoSuccess;
    procedure DoFailure;
    procedure DoCancel;
    procedure DoComplete;
    procedure DoProgress;
    function GetState: TWorkState;
    function GetObject: TObject;
    property Owner: TWorker write SetOwner;
    property State: TWorkState read GetState;
  end;

  {$interfaces com}

  { TWork }

  generic TWork<T> = class abstract (IWork)
  type
    TSelf = specialize TWork<T>;
    TError = record
      Code: Integer;
      Message: string;
      ClassType: TClass;
    end;
    TOnSuccess = procedure (Sender: TSelf; Return: T) of object;
    TOnFailure = procedure (Sender: TSelf; Error: TError) of object;
    TOnComplete = procedure (Sender: TSelf) of object;
    TOnProgress = procedure (Sender: TSelf) of object;
    TOnCancel = procedure (Sender: TSelf) of object;
  private
    FState: TWorkState;
    procedure SetOwner(TheOwner: TWorker);
    function GetState: TWorkState;
  protected
    FWorker: TWorker;
    FOnSuccess: TOnSuccess;
    FOnFailure: TOnFailure;  
    FOnComplete: TOnComplete;
    FOnProgress: TOnProgress;
    FOnCancel: TOnCancel;
    FReturn: T;
    FError: TError;
    function Execute: T; virtual; abstract; // Implemented code should always check Canceling state mannully
    procedure Run;
    procedure DoSuccess;
    procedure DoFailure;
    procedure DoCancel;
    procedure DoComplete;
    procedure DoProgress;
  public
    constructor Create;
    property OnSuccess: TOnSuccess read FOnSuccess write FOnSuccess;
    property OnFailure: TOnFailure read FOnFailure write FOnFailure;  
    property OnComplete: TOnComplete read FOnComplete write FOnComplete;
    property OnProgress: TOnProgress read FOnProgress write FOnProgress;  
    property OnCancel: TOnCancel read FOnCancel write FOnCancel;
    property Return: T read FReturn;
    property Error: TError read FError;
    property Owner: TWorker read FWorker;
    property State: TWorkState read GetState;
    function GetObject: TObject;
    function Completed: boolean;
    function Succeeded: boolean;
    function Pending: boolean;
    function Running: boolean;
    function Failed: boolean;
    function Cancelled: boolean;
    function Canceling: boolean;
    procedure Cancel;
  end;

  { TWorker }

  TWorker = class(TThread)
  private
    FWork: IWork;
    FWorkPool: TWorkPool;
    function GetIdle: boolean;
    procedure SetWork(AValue: IWork);
  protected
    procedure Execute; override;
    procedure TerminatedSet; override;
    procedure DoWorkComplete;
    property Work: IWork read FWork write SetWork;
    property Idle: boolean read GetIdle;
  public
    constructor Create(WorkPool: TWorkPool);
    destructor Destroy; override;
  end;

  { TWorkPool }

  TWorkPool = class(TObject)
  private
    FCapacity: TWorkPoolCapacity;
    FWorkQueue: TObjectQueue;
    FWorkers: TObjectList;
    function GetState: TWorkPoolState;
    function GetWorkerCount: Integer;
    function GetIdleWorker: TWorker;
    procedure SetCapacity(AValue: TWorkPoolCapacity);
    procedure Trigger;
  public
    constructor Create(ACapacity: TWorkPoolCapacity);
    destructor Destroy; override;
    property Capacity: TWorkPoolCapacity read FCapacity write SetCapacity;
    property WorkerCount: Integer read GetWorkerCount;
    property WorkQueue: TObjectQueue read FWorkQueue;
    property State: TWorkPoolState read GetState;
    function ReduceWorkers(Count: Integer): Integer;
    procedure Exec(Work: IWork);
  end;

var
  WorkPool: TWorkPool;

implementation

{ TWork }

constructor TWork.Create;
begin
  FState := wsPending;
end;

function TWork.Completed: boolean;
begin
  Result := FState in [wsSucceeded, wsFailed];
end;

function TWork.Succeeded: boolean;
begin
  Result := FState = wsSucceeded;
end;

function TWork.Pending: boolean;
begin
  Result := FState = wsPending;
end;

function TWork.Running: boolean;
begin
  Result := FState = wsRunning;
end;

function TWork.Failed: boolean;
begin
  Result := FState = wsFailed;
end;

function TWork.Cancelled: boolean;
begin
  Result := FState = wsCancelled;
end;

function TWork.Canceling: boolean;
begin
  Result := FState = wsCanceling;
end;

function TWork.GetObject: TObject;
begin
  Result := Self;
end;

procedure TWork.SetOwner(TheOwner: TWorker);
begin
  if Assigned(FWorker) then raise EWorkResetWorker.Create('The worker is already set');
  if not TheOwner.Idle then raise EWorkBusyWorker.Create('Target worker is not idle');
  FWorker := TheOwner;
end;

function TWork.GetState: TWorkState;
begin
  Result := FState;
end;

procedure TWork.Run;
begin
  FState := wsRunning;
  try
    FReturn := Execute;
    FState := wsSucceeded;
  except
    on Exc: EWorkCancel do
    begin
      FState := wsCancelled;
    end;
    on Exc: Exception do
    begin
      FError.Code := 0;
      FError.Message := Exc.Message;
      FError.ClassType := Exc.ClassType;
      { todo: Error extends }
      FState := wsFailed;
    end;
  end;
end;

procedure TWork.DoSuccess;
begin
  if Assigned(FOnSuccess) then FOnSuccess(Self, FReturn);
  DoComplete;
end;

procedure TWork.DoFailure;
begin
  if Assigned(FOnFailure) then FOnFailure(Self, FError);
  DoComplete;
end;

procedure TWork.DoCancel;
begin
  if Assigned(FOnCancel) then FOnCancel(Self);
  DoComplete;
end;

procedure TWork.DoComplete;
begin
  if Assigned(FOnComplete) then FOnComplete(Self);
end;

procedure TWork.DoProgress;
begin
  if Assigned(FOnProgress) then FOnProgress(Self);
end;

procedure TWork.Cancel;
begin
  if GetCurrentThreadID = FWorker.ThreadID then
    raise EWorkCancel.Create(EmptyStr)
  else
    FState := wsCanceling;
end;

{ TWorker }

function TWorker.GetIdle: boolean;
begin
  Result := Suspended and not Assigned(FWork);
end;

procedure TWorker.SetWork(AValue: IWork);
begin                  
  AValue.Owner := Self;
  FWork := AValue;
end;

procedure TWorker.Execute;
begin
  while not Terminated do
  begin
    FWork.Run;
    Synchronize(@DoWorkComplete);
  end;
end;

procedure TWorker.TerminatedSet;
begin
  if Assigned(FWork) and (FWork.State = wsRunning) then FWork.Cancel;
end;

procedure TWorker.DoWorkComplete;
begin
  try
    case FWork.State of
      wsSucceeded: FWork.DoSuccess;
      wsFailed: FWork.DoFailure;
      wsCancelled: FWork.DoCancel;
    end;
  except
    on Exc: Exception do;
  end;
  FWork.GetObject.Free;
  FWork := nil;
  if not Terminated then
  begin
    Suspended := True;
    FWorkPool.Trigger;
  end;
end;

constructor TWorker.Create(WorkPool: TWorkPool);
begin
  inherited Create(True);
  FWorkPool := WorkPool;
end;

destructor TWorker.Destroy;
begin
  inherited Destroy;
end;

{ TWorkPool }

procedure TWorkPool.SetCapacity(AValue: TWorkPoolCapacity);
begin
  if FCapacity = AValue then Exit;
  FCapacity := AValue;
end;

function TWorkPool.GetWorkerCount: Integer;
begin
  Result := FWorkers.Count;
end;

function TWorkPool.GetState: TWorkPoolState;
var
  Number: Integer;
begin
  Number := WorkerCount;
  if Number = 0 then Exit(wpsEmpty);
  if Number < FCapacity then Exit(wpsNotFull);
  if Number = FCapacity then Exit(wpsFull);
  Result := wpsOverload;
end;


constructor TWorkPool.Create(ACapacity: TWorkPoolCapacity);
begin
  FCapacity := ACapacity;
  FWorkQueue := TObjectQueue.Create;
  FWorkers := TObjectList.Create;
end;

destructor TWorkPool.Destroy;
var
  Item: Pointer;
begin
  for Item in FWorkers do
  begin
    with TWorker(Item) do Terminate;
  end;
  FWorkers.Free; // block wait for all worker terminated
  FWorkQueue.Free;
  inherited;
end;

function TWorkPool.ReduceWorkers(Count: Integer): Integer;
var
  Worker: TWorker;
  i: Integer = 0;
begin
  Result := 0;
  while (i < FWorkers.Count) and (Result < Count) do
  begin
    Worker := TWorker(FWorkers[i]);
    if Worker.Idle then
    begin
      Worker.Terminate;
      Worker.Suspended := False;
      Worker.WaitFor;
      FWorkers.Delete(i);
      Inc(Result);
    end
    else Inc(i);
  end;
end;

function TWorkPool.GetIdleWorker: TWorker;
var
  Item: Pointer;
begin
  for Item in FWorkers do
  begin
    Result := TWorker(Item);
    if Result.Idle then Exit(Result);
  end;
  if State in [wpsFull, wpsOverload] then Exit(nil);
  Result := TWorker.Create(Self);
  FWorkers.Add(Result);
end;

procedure TWorkPool.Exec(Work: IWork);
begin
  FWorkQueue.Push(Work.GetObject);
  Trigger;
end;

procedure TWorkPool.Trigger;
var
  Worker: TWorker;
  Work: IWork;
begin
  if State = wpsOverload then ReduceWorkers(WorkerCount - FCapacity);
  if FWorkQueue.Count = 0 then Exit;
  Worker := GetIdleWorker;
  if Assigned(Worker) and Supports(FWorkQueue.Pop, IWork, Work) then
  begin
    Worker.Work := Work;
    Worker.Suspended := False;
  end;
end;


initialization

WorkPool := TWorkPool.Create(Config.WorkPool.Capacity);

finalization

FreeAndNil(WorkPool);

end.

